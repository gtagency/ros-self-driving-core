/* Auto-generated by genmsg_cpp for file /home/viki/catkin_ws/src/roscorobot/Corobot/PhidgetMotor/srv/Move.srv */
#ifndef PHIDGETMOTOR_SERVICE_MOVE_H
#define PHIDGETMOTOR_SERVICE_MOVE_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"




namespace PhidgetMotor
{
template <class ContainerAllocator>
struct MoveRequest_ {
  typedef MoveRequest_<ContainerAllocator> Type;

  MoveRequest_()
  : leftSpeed(0)
  , rightSpeed(0)
  , secondsDuration(0)
  , acceleration(0)
  {
  }

  MoveRequest_(const ContainerAllocator& _alloc)
  : leftSpeed(0)
  , rightSpeed(0)
  , secondsDuration(0)
  , acceleration(0)
  {
  }

  typedef int16_t _leftSpeed_type;
  int16_t leftSpeed;

  typedef int16_t _rightSpeed_type;
  int16_t rightSpeed;

  typedef uint16_t _secondsDuration_type;
  uint16_t secondsDuration;

  typedef uint16_t _acceleration_type;
  uint16_t acceleration;


  typedef boost::shared_ptr< ::PhidgetMotor::MoveRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::PhidgetMotor::MoveRequest_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct MoveRequest
typedef  ::PhidgetMotor::MoveRequest_<std::allocator<void> > MoveRequest;

typedef boost::shared_ptr< ::PhidgetMotor::MoveRequest> MoveRequestPtr;
typedef boost::shared_ptr< ::PhidgetMotor::MoveRequest const> MoveRequestConstPtr;


template <class ContainerAllocator>
struct MoveResponse_ {
  typedef MoveResponse_<ContainerAllocator> Type;

  MoveResponse_()
  : succeeded(false)
  {
  }

  MoveResponse_(const ContainerAllocator& _alloc)
  : succeeded(false)
  {
  }

  typedef uint8_t _succeeded_type;
  uint8_t succeeded;


  typedef boost::shared_ptr< ::PhidgetMotor::MoveResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::PhidgetMotor::MoveResponse_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct MoveResponse
typedef  ::PhidgetMotor::MoveResponse_<std::allocator<void> > MoveResponse;

typedef boost::shared_ptr< ::PhidgetMotor::MoveResponse> MoveResponsePtr;
typedef boost::shared_ptr< ::PhidgetMotor::MoveResponse const> MoveResponseConstPtr;

struct Move
{

typedef MoveRequest Request;
typedef MoveResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct Move
} // namespace PhidgetMotor

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::PhidgetMotor::MoveRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::PhidgetMotor::MoveRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::PhidgetMotor::MoveRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "451c087bf7cd0b5ee063409877e152e9";
  }

  static const char* value(const  ::PhidgetMotor::MoveRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x451c087bf7cd0b5eULL;
  static const uint64_t static_value2 = 0xe063409877e152e9ULL;
};

template<class ContainerAllocator>
struct DataType< ::PhidgetMotor::MoveRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PhidgetMotor/MoveRequest";
  }

  static const char* value(const  ::PhidgetMotor::MoveRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::PhidgetMotor::MoveRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
int16 leftSpeed\n\
int16 rightSpeed\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
uint16 secondsDuration\n\
\n\
\n\
\n\
\n\
\n\
\n\
uint16 acceleration\n\
\n\
";
  }

  static const char* value(const  ::PhidgetMotor::MoveRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::PhidgetMotor::MoveRequest_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::PhidgetMotor::MoveResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::PhidgetMotor::MoveResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::PhidgetMotor::MoveResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "95e696a0d10686913abb262e0b4cbbcf";
  }

  static const char* value(const  ::PhidgetMotor::MoveResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x95e696a0d1068691ULL;
  static const uint64_t static_value2 = 0x3abb262e0b4cbbcfULL;
};

template<class ContainerAllocator>
struct DataType< ::PhidgetMotor::MoveResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PhidgetMotor/MoveResponse";
  }

  static const char* value(const  ::PhidgetMotor::MoveResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::PhidgetMotor::MoveResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
\n\
\n\
\n\
bool succeeded\n\
\n\
\n\
";
  }

  static const char* value(const  ::PhidgetMotor::MoveResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::PhidgetMotor::MoveResponse_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::PhidgetMotor::MoveRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.leftSpeed);
    stream.next(m.rightSpeed);
    stream.next(m.secondsDuration);
    stream.next(m.acceleration);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct MoveRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::PhidgetMotor::MoveResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.succeeded);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct MoveResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<PhidgetMotor::Move> {
  static const char* value() 
  {
    return "69ab499da909d189bb9422ee7dce103d";
  }

  static const char* value(const PhidgetMotor::Move&) { return value(); } 
};

template<>
struct DataType<PhidgetMotor::Move> {
  static const char* value() 
  {
    return "PhidgetMotor/Move";
  }

  static const char* value(const PhidgetMotor::Move&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<PhidgetMotor::MoveRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "69ab499da909d189bb9422ee7dce103d";
  }

  static const char* value(const PhidgetMotor::MoveRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<PhidgetMotor::MoveRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PhidgetMotor/Move";
  }

  static const char* value(const PhidgetMotor::MoveRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<PhidgetMotor::MoveResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "69ab499da909d189bb9422ee7dce103d";
  }

  static const char* value(const PhidgetMotor::MoveResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<PhidgetMotor::MoveResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "PhidgetMotor/Move";
  }

  static const char* value(const PhidgetMotor::MoveResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // PHIDGETMOTOR_SERVICE_MOVE_H

